# Trouble Shooting

## 이미지 저장

상품 업로드 시 추가 이미지를 함께 업로드할 수 있도록 구성했습니다.  
하나는 대표 이미지(썸네일)이며, 나머지는 쇼핑몰에서 흔히 볼 수 있는 상품 설명용 이미지들입니다.

초기에는 막연하게 DTO에 MultipartFile을 직접 포함시켰지만, 이는 잘못된 구조였습니다.  
DTO는 기본적으로 데이터 통신을 위한 객체이며, 프레임워크(SPRING)에 의존성을 가지지 않아야 합니다.  
이에 따라 DTO에는 이미지 파일 자체가 아닌, 이미지 이름이나 타입과 같은 메타데이터만 선언하도록 수정했습니다.

구조를 개선하면서 한 가지 고민이 생겼습니다.  
"서비스 단에서 업로드된 이미지가 어떤 상품에 매칭되는지, 순서만으로 구분할 수 있을까?" 하는 문제였습니다.  
단순 반복문만으로는 정확한 매칭이 어려울 수 있다고 판단하여,  
**Map** 구조를 도입하여 Key(이미지 정보)와 Value(실제 이미지 파일)를 매칭하는 방식으로 개선했습니다.

결과적으로 이미지 업로드 메서드는  
`Map<DTO(이미지 정보, DB에 저장할 데이터), IMAGE(실제 업로드할 파일)>`  
형태로 구성되어, 이미지 파일과 데이터의 일관성을 안전하게 유지할 수 있게 되었습니다.

---

### 핵심 정리

- 문제: DTO에 MultipartFile을 직접 담아 스프링 의존성이 발생
- 원인: DTO가 스프링에 종속되는 구조였음
- 해결:
  - DTO에는 파일 메타데이터만 선언
  - 서비스 단에서 파일 처리
  - Map<DTO, File> 구조로 명확한 매핑 구현

---

## 상품 수정

상품 수정 시 `OptimisticLockingFailureException`(버전 불일치) 오류가 발생했습니다.

상품은 이미지, 카테고리, 옵션 등 다양한 연관관계를 맺고 있으며,  
상품 ID를 기준으로 여러 테이블(상품, 이미지, 옵션, 카테고리)에서 수정 작업이 동시에 이루어져야 했습니다.

처음 수정 기능을 구현할 때는  
- 옵션은 삽입/삭제뿐만 아니라 기존 데이터의 변경 감지(update)가 필요했고,  
- 이미지는 실제 파일 업로드/삭제가 이루어져야 했습니다.  

이러한 다양한 요구사항을 하나의 메소드에서 처리하다 보니,  
특히 옵션 수정 과정에서 `OptimisticLockingFailureException` 이 발생했습니다.  
(옵션 수정 과정 중, 동일 엔티티에 대해 연속적인 변경이 이루어지면서 버전 충돌이 발생한 것으로 추정)

이를 해결하기 위해 다음과 같은 구조 개선을 적용했습니다.

1. 기존 옵션 수정 (`updateExist`)  
2. 신규 옵션 삽입 (`newOption`)  
3. 옵션 삭제 (`deleteOption`)  

**이 세 가지 작업을 각각 별도의 메소드로 분리하고**,  
최종적으로 `update` 메소드에서 이들을 호출하는 방식으로 변경했습니다.  

또한, 메소드 분리만으로 끝내지 않고,  
**전체 update 프로세스는 하나의 트랜잭션 안에서 실행되도록 구성**하여,  
다른 작업이 중간에 커밋된 후 롤백될 경우 발생할 수 있는 데이터 정합성 문제도 예방했습니다.

---

### 핵심 정리

- 문제: 상품 수정 시 `OptimisticLockingFailureException` 발생 (버전 충돌)
- 원인: 하나의 메소드 내에서 연속적인 변경 작업이 이루어짐
- 해결:
  - 옵션 수정/삽입/삭제 작업을 별도 메소드로 분리
  - 전체 과정을 하나의 트랜잭션으로 묶어 정합성 확보

---

## JPA N+1 문제

주문(Order)과 주문상품(OrderItem) 엔티티를 설계하면서,  
연관관계 매핑에 따른 `N+1 문제`를 경험했습니다.

주문 목록을 조회할 때 주문상품이 여러 개 연결되면,  
주문 수만큼 추가적인 SELECT 쿼리가 발생하여 성능 저하가 발생합니다.  
이는 실제 서비스 환경에서 심각한 부하를 초래할 수 있습니다.

N+1 문제를 해결하기 위해 기본적으로 FetchType.LAZY를 적용하고,  
필요한 경우 BatchSize 조절을 통해 성능을 개선했습니다.  
그러나 근본적인 해결을 위해 대부분 **FETCH JOIN** 쿼리를 사용하여 필요한 데이터를 한 번에 가져오는 방식을 적용했습니다.

---

### 핵심 정리

- 문제: 주문 조회 시 N+1 쿼리 문제 발생
- 원인: LAZY 로딩으로 인해 연관 데이터 조회 시 추가 SELECT 발생
- 해결:
  - 기본적으로 FetchType.LAZY 적용
  - 실질 조회 시 FETCH JOIN을 사용하여 한 번에 조회

---

## 시간 문제

DB에 저장되는 시간 정보가 내가 의도한 시간과 다르게 저장되는 문제가 발생했습니다.  
이는 기본적으로 데이터베이스가 `UTC` 시간대를 사용하기 때문이었습니다.

`application.properties` 설정 파일에  
`Time_Zone`을 `Asia/Seoul`로 설정하여,  
서버와 DB 간의 시간 차이를 해결했습니다.

---

### 핵심 정리

- 문제: DB에 저장되는 시간과 실제 시간이 다름
- 원인: 기본 시간대(UTC) 사용
- 해결:
  - 서버 Time_Zone을 Asia/Seoul로 설정

---

## 여러 스레드에서 동시에 주문이 들어온다면?

기본적인 주문 테스트는 성공했지만, 실제 서비스 환경에서 사용자 트래픽이 몰릴 경우를 고려해야 했습니다.  
이를 테스트하기 위해 임의로 10개의 스레드를 만들어 동시에 주문 요청을 보내보았습니다.
결과적으로 트랜잭션 경합이 발생하여 데드락이 발생했고,  
이를 해결하기 위해 주문 로직 내에서 **비관적 락(Pessimistic Lock)** 을 적용했습니다.  
이를 통해 재고 감소 등 동시성 문제가 발생하지 않도록 안전성을 확보했습니다.

---

### 핵심 정리

- 문제: 동시 주문 요청 시 데드락 발생
- 원인: 다수의 트랜잭션 경합
- 해결:
  - 주문 로직에 비관적 락(Pessimistic Lock) 적용

---

## 테스트 코드의 반복적인 사용

테스트 코드 작성 과정에서 `ObjectMapper`, `MockMvc` 등 공통적으로 사용되는 도구를  
각 테스트 클래스에서 반복적으로 작성하는 비효율적인 문제가 있었습니다.

또한, 멤버 로그인 상태가 필요한 상품 등록이나 장바구니 테스트에서는  
매번 토큰 발급 로직을 중복 작성해야 했습니다.

이 문제를 해결하기 위해 **공통 설정(Abstract Class)** 을 분리하여,  
필요한 기본 정보 세팅을 재사용할 수 있도록 개선했습니다.  
이를 통해 테스트 코드의 중복을 줄이고 유지보수성을 높일 수 있었습니다.

---

### 핵심 정리

- 문제: 테스트 코드에서 반복적인 세팅 코드 발생
- 원인: 공통 객체(ObjectMapper, MockMvc) 및 토큰 발급 로직 중복
- 해결:
  - 공통 설정을 Abstract Class로 분리하여 재사용성 강화

---

## ArgumentResolver 적용

토큰 인증 과정에서 사용자 식별을 보다 유연하게 처리하기 위해  
**커스텀 ArgumentResolver**를 구현했습니다.

Spring Security에서는 기본적으로 `@AuthenticationPrincipal` 어노테이션을 제공하지만,  
`CustomUserDetails`를 활용하여 멤버 상태(활성/비활성 여부, 마지막 로그인 날짜 등)를 쉽게 파악할 수 있도록 개선했습니다.

`loadUserByUsername` 메소드에서는 멤버의 로그인 가능 여부를 판별하여  
`CustomUserDetails`를 리턴하고,  
토큰 생성 시에는 최소한의 정보(식별자)만 추출하여 불필요한 DB 접근을 방지했습니다.

결국 서비스 로직에서는 토큰에 담긴 식별자를 이용해 필요한 시점에 DB 조회를 수행하여,  
비즈니스 로직에 안전하게 접근할 수 있도록 설계했습니다.

---

### 핵심 정리

- 문제: 토큰 기반 사용자 식별 과정 복잡
- 원인: 인증 과정에서 사용자 상태를 명확히 파악하기 어려움
- 해결:
  - Custom ArgumentResolver 도입
  - CustomUserDetails를 통해 사용자 상태를 직접 관리
  - 최소한의 토큰 정보로 인증 처리
